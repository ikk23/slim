// Author: Sam Champer and Isabel Kim.
// Created in association with Jackson Champer and the Messer lab.

// A framework for simulating many different gene drives
// with varying parameters, intended to be configured by
// alterning the heading below, or by dynamically varying
// values in the header using an associated Python file.

//These gene drives are located on a sex chromosome and target the 
//opposite sex chromosome.
//This landscape is simulated in 2 dimensions.

// The following header to be replaced via python,
// such that these values can be varied across multiple runs of slim.
initialize() {
	defineConstant("CAPACITY", 40000);
	defineConstant("DENSITY_INTERACTION_DISTANCE", 0.01);
	defineConstant("DRIVE_FITNESS_VALUE", 0.95);
	defineConstant("DROP_SIZE", 404);
	defineConstant("DROP_RADIUS", 0.01);
	defineConstant("EMBRYO_RESISTANCE_RATE", 0.0);
	defineConstant("GERMLINE_RESISTANCE_RATE", 0.99);
	defineConstant("GROWTH_AT_ZERO_DENSITY", 9);
	defineConstant("HETEROZYGOUS_DROP", F);
	defineConstant("MALE_ONLY_DROP", T);
	defineConstant("FEMALE_ONLY_DROP", F);
	defineConstant("NUM_GRNAS", 1);
	defineConstant("R1_OCCURRENCE_RATE", 0.0);
	defineConstant("SPEED", 0.03);
	defineConstant("X_SHREDDER", T);
	defineConstant("Y_SHREDDER", F);
	defineConstant("TRACK_BY_CELL", T);
	defineConstant("TRACK_RIPLEYS_L", F);
	defineConstant("NUMBER_OF_CELLS", 64);
	defineConstant("NO_DROP", F);
	
	// */    // End header.
	
	// Below are constants that probably won't change
	defineConstant("CIRCLE_DROP", T);
	defineConstant("FEMALE_SPEED", SPEED);
	defineConstant("GRNA_SATURATION_SIMULATED", F);
	defineConstant("INBREEDING_AVOIDANCE_FACTOR", 0.0);
	defineConstant("LEFT_EDGE_DROP", F);
	defineConstant("MALE_MATE_CAP", F);
	defineConstant("MAX_MALE_MATINGS", 10);
	defineConstant("MALE_ONLY_PROMOTER", F);
	defineConstant("MATING_DISTANCE", SPEED);
	defineConstant("NUM_CUT_PHASES", 1);
	defineConstant("EQUILIBRIUM_WT_ALLELE_THRESHOLD", 0.8*1.5*CAPACITY);
	defineConstant("R2_FITNESS_VALUE", 1.0);
	defineConstant("REPRISING_BOUNDARIES", T);
	defineConstant("START_AT_CHASE", F);
	defineConstant("CSV_FOR_GC", F);
	
	
	// For mortality rate as a function of age. Some females are allowed to survive two generations:
	defineConstant("RATE_FEMALES_SURVIVE", 0.0);
	
	// This simulation will use a non-Wright-Fisher model.
	initializeSLiMModelType("nonWF");
	
	// This simulation will take place accross continuous space.
	// By default, model occurs in a torroidal space to prevent edge effects.
	// The model tracks pedigrees in order to implement inbreeding avoidance.
	if (REPRISING_BOUNDARIES)
		initializeSLiMOptions(keepPedigrees=T, dimensionality="xy");
	else
		initializeSLiMOptions(keepPedigrees=T, dimensionality="xy", periodicity="xy");
	
	// Four variations: Wild type, drive, r1 resistance, r2 resistance.
	wt = initializeMutationType("m1", 0.5, "f", 0.0);
	dr = initializeMutationType("m2", 0.5, "f", 0.0);
	r1 = initializeMutationType("m3", 0.5, "f", 0.0);
	r2 = initializeMutationType("m4", 0.5, "f", 0.0);
	cut = initializeMutationType("m5", 0.5, "f", 0.0);
	gap = initializeMutationType("m6", 0.5, "f", 0.0);
	variations = c(wt, dr, r1, r2, cut, gap);
	
	// Variations are all part of g1 genome element.
	initializeGenomicElementType("g1", variations, c(1, 1, 1, 1, 1, 1));
	
	// Element is NUM_GRNAS long, each spot on the element representing a GRNA target location.
	initializeGenomicElement(g1, 0, NUM_GRNAS - 1);
	
	// These mutations overwrite one another.
	variations.mutationStackPolicy = "l";
	variations.mutationStackGroup = 1;
	
	// No mutation in this model.
	initializeMutationRate(0.0);
	initializeRecombinationRate(0.0);
	
	// Simulate sexual reproduction: A for autosome.
	//initializeSex("A");
	
	// Mate searching: Default interaction has strength 1 for individuals within max distance, 0 for others.
	initializeInteractionType(1, "xy", reciprocal=T, maxDistance=MATING_DISTANCE);
	// Adult competition:
	initializeInteractionType(2, "xy", reciprocal=T, maxDistance=DENSITY_INTERACTION_DISTANCE);
	// For now, just modeling interaction with flat strength of 1.
	// i2.setInteractionFunction("n", 1.0, DENSITY_INTERACTION_DISTANCE);
	
	//Used to track Ripley's L between wt individiauls for chasing analysis when TRACK_RIPLEYS_L is true
	initializeInteractionType(3, "xy", reciprocal=T, maxDistance=DENSITY_INTERACTION_DISTANCE);
	
	// Constants based on other constants:
	// Rate of expected competition
	defineConstant("EXPECTED_ADULT_COMPETITION", CAPACITY * PI * DENSITY_INTERACTION_DISTANCE^2);
}


//// HELPER FUNCTION FOR FORMING A RESISTANCE ALLELE AT A GIVEN LOCUS.
function (void)addResistanceAllele(o<Genome>$ genome, i$ locus) {
	// Resistance alleles form at a specified rate.	m3 is r1, m4 is r2.
	genome.addNewDrawnMutation(ifelse((runif(1) < R1_OCCURRENCE_RATE), m3,m4), locus);
}


//// FUNCTION FOR CAS9 EFFECTS IN THE GERMLINE.
function (void)germline(o<Genome>$ child_chromosome, o<Individual>$ parent, f$ resistance_rate) {
	// Determine presence of drive in this parent.
	parent_drive_count = sum(parent.genomes.countOfMutationsOfType(m2) == NUM_GRNAS);
	// If parent doesn't have drive allele, nothing happens in germline.
	if (!parent_drive_count)
		return;
	
	// Chromosome must have wt to cut, or nothing happens.
	if (child_chromosome.countOfMutationsOfType(m1) == 0)
		return;
	
	// Using the resistance rate passed to the function,
	// determine the per phase cut rate.
	grna_factor = 1;
	if (GRNA_SATURATION_SIMULATED)
		grna_factor = NUM_GRNAS;
	per_phase_cut_rate = 1 - (1 - resistance_rate)^(1 / (NUM_CUT_PHASES * grna_factor));
	
	// Determine if cas9 cuts the chromosome in the germline.
	casCut(child_chromosome, per_phase_cut_rate);
}


//// FUNCTION FOR CAS9 EFFECTS IN EMBRYO.
function (void)embryo(o<Genome>$ child_chromosome_1, o<Genome>$ child_chromosome_2, o<Individual>$ mother) {
	// Determine presence of drive in this mother.
	mother_drive_count = sum(mother.genomes.countOfMutationsOfType(m2) == NUM_GRNAS);
	// If mother doesn't have drive allele, nothing happens in embryo.
	if (!mother_drive_count)
		return;
	grna_factor = 1;
	if (GRNA_SATURATION_SIMULATED)
		grna_factor = NUM_GRNAS;
	per_phase_cut_rate = 1 - (1 - EMBRYO_RESISTANCE_RATE)^(mother_drive_count / (NUM_CUT_PHASES * grna_factor));
	
	// Then pass this rate as an argument to  the casCut funtion to
	// determine if cas9 cuts in the embryo for each chromosome.
	casCut(child_chromosome_1, per_phase_cut_rate);
	casCut(child_chromosome_2, per_phase_cut_rate);
}


//// FUNCTION FOR CAS9 CUTTING A TARGET CHROMOSOME.
function (void)casCut(o<Genome>$ chromosome, f$ per_phase_cut_rate) {
	// If chromosome has no wild type targets to cut, cas9 does nothing.
	if (chromosome.countOfMutationsOfType(m1) == 0)
		return;
	
	// Vector of possible loci for cas9 to cut:
	wt_loci = chromosome.positionsOfMutationsOfType(m1);
	
	// In each cut phase...
	for (i in seqLen(NUM_CUT_PHASES)) {
		// At each possible locus...
		for (j in seqAlong(wt_loci)) {
			// Check to see if cas9 cuts...
			if (runif(1) < per_phase_cut_rate) {
				// Convert the locus temporarily to an m5,
				// representing that this site is being cut.
				chromosome.addNewDrawnMutation(m5, wt_loci[j]);
			}
		}
		// If any cuts were made...
		if (chromosome.countOfMutationsOfType(m5)) {
			cut_loci = chromosome.positionsOfMutationsOfType(m5);
			// If just one cut is made, create an R1 or R2 resistance allele.
			if (chromosome.countOfMutationsOfType(m5) == 1)
				addResistanceAllele(chromosome, cut_loci[0]);
			else {
				// If multiple cuts are made in the same cut phase, loss of
				// function results. Convert leftmost site to m4 (R2)
				// everthing else through the rightmost site to m6 (cut).
				number_of_cuts = cut_loci[size(cut_loci) - 1] - cut_loci[0];
				for (index in seqLen(number_of_cuts))
					chromosome.addNewDrawnMutation(m6, cut_loci[0] + index + 1);
				chromosome.addNewDrawnMutation(m4, cut_loci[0]);
			}
			// Because some wt loci may have been cut out of the
			// chromosome, remake the vector of possible cut sites.
			if (chromosome.countOfMutationsOfType(m1) == 0)
				return;
			wt_loci = chromosome.positionsOfMutationsOfType(m1);
		}
	}
}


//// HELPER FUNCTION TO OVERWRITE ONE GENOME WITH ANOTHER.
function (void)copy_genome(o<Genome>$ source, o<Genome>$ destination) {
	for (i in seqAlong(source.positionsOfMutationsOfType(m1))) //m1 loci (wt)
		destination.addNewDrawnMutation(m1, source.positionsOfMutationsOfType(m1)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m2))) //m2 loci (dr)
		destination.addNewDrawnMutation(m2, source.positionsOfMutationsOfType(m2)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m3))) //m3 loci (r1)
		destination.addNewDrawnMutation(m3, source.positionsOfMutationsOfType(m3)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m4))) //m4 loci (r2)
		destination.addNewDrawnMutation(m4, source.positionsOfMutationsOfType(m4)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m5))) //m5 loci (cut)
		destination.addNewDrawnMutation(m5, source.positionsOfMutationsOfType(m5)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m6))) //m6 loci (gap)
		destination.addNewDrawnMutation(m6, source.positionsOfMutationsOfType(m6)[i]);
}


//// RULES FOR FITNESS BASED ON GENOTYPE.
function (f$)genotypeFitness(o<Individual>$ ind) {
	// Representation of the value of the two chromosomes. Check for drive or wt to get the baseline value.
	c1_value = ifelse(ind.genome1.countOfMutationsOfType(m2) == NUM_GRNAS, DRIVE_FITNESS_VALUE, 1.0);
	c2_value = ifelse(ind.genome2.countOfMutationsOfType(m2) == NUM_GRNAS, DRIVE_FITNESS_VALUE, 1.0);
	
	// Check both chromosomes for resistance allele.
	if (ind.genome1.countOfMutationsOfType(m4) > 0)
		c1_value = c1_value * R2_FITNESS_VALUE;
	if (ind.genome2.countOfMutationsOfType(m4) > 0)
		c2_value = c2_value * R2_FITNESS_VALUE;
	
	return ifelse(X_SHREDDER, c2_value, sqrt(c1_value*c2_value));
}

//// OUTPUT WHEN TRACKING RIPLEY'S L 
// this will output <generation>,<wt ind count>,<ripley's L> to a csv file
function (void)outputRipleysL([string$ result=""]) {
	wt_counts = sim.getValue("wts");
	L = sim.getValue("L");
	path = getwd() + "/" + asString(getSeed()) + "_" + result + "_shredder_drives_2d_L.csv";
	file = "generation,wt allele count, ripley's l\n";
	
	for (i in seqAlong(wt_counts))
		file = file + asString(i) + ',' + asString(wt_counts[i]) + ',' + asString(L[i]) + '\n';
	
	if (!writeFile(path, file))
		stop("error writing file."); //check if there's an issue
}

//// OBTAIN THE AVG GC AND VARIANCE WHEN TRACKING BY CELL COUNTT
function (void)outputGreensCoefficient([string$ result=""])  {
	
	path = getwd() + "/" + asString(getSeed()) + "_" + result + "_GC_over_gens_same_site_2d.csv";
	file = "GC\n";
	
	for (i in seqAlong(GC_space)) {
		this_gc = GC_space[i];
		file = file + asString(this_gc) + '\n';
	}
	if (!writeFile(path, file))
		stop("error writing file."); //check if there's an issue
}




////REPRODUCTION CALLBACK
reproduction() {
	//only sample females for reproduction
	if (individual.tagF == 1.0) {
		all_neighbors = i1.nearestNeighbors(individual, subpop.individualCount);
		neighbors = all_neighbors[all_neighbors.tagF == 0.0];
		if (size(neighbors) == 0)
			return;
		attempt_no = 0;
		while (1) {
			// First, select a random mate.
			mate_no = 0;
			if (size(neighbors) > 1)
				mate_no = rdunif(1, max=size(neighbors) - 1);
			selected_mate = neighbors[mate_no];
			// Determine attractiveness of mate.
			mate_attractiveness = genotypeFitness(selected_mate);
			if (selected_mate.pedigreeParentIDs[0] == individual.pedigreeParentIDs[0] & individual.pedigreeParentIDs[0] != -1)
				mate_attractiveness = mate_attractiveness * (1 - INBREEDING_AVOIDANCE_FACTOR);
			
			// Determine if this mate is chosen, based on attractiveness and number of mates so far.
			if (MALE_MATE_CAP) {
				if ((runif(1) < mate_attractiveness) & (selected_mate.getValue("mates") < MAX_MALE_MATINGS)) {
					selected_mate.setValue("mates", selected_mate.getValue("mates") + 1); //increment his mate count
					break;  // Select this mate.
				}
			} else {
				if (runif(1) < mate_attractiveness)
					break;
			}
			// After ten candidates fail, female gives up.
			attempt_no = attempt_no + 1;
			if (attempt_no == 9)
				return;
		} // Mate has now been selected. 
		
		// Amount of competition faced per expected competition.
		adult_density_force = i2.totalOfNeighborStrengths(individual);
		competition_ratio = adult_density_force / EXPECTED_ADULT_COMPETITION;
		actual_competition_factor = GROWTH_AT_ZERO_DENSITY/ ((GROWTH_AT_ZERO_DENSITY-1) * competition_ratio + 1);
		
		// Offspring number based on binomial distrobution.
		// p for binomial draw. Number of offspring varies with female genes and competition.
		p = genotypeFitness(individual) * actual_competition_factor * 0.04 / (1 + RATE_FEMALES_SURVIVE);
		
		num_offspring = rbinom(1, 50, p);
		
		for (i in seqLen(num_offspring)) {
			// Add offspring to the subpopulation.
			offspring = subpop.addCrossed(individual, selected_mate);
			if (!isNULL(offspring)) {
				if (REPRISING_BOUNDARIES) {
					// Offspring placement within reprising boundaries.
					do position = individual.spatialPosition + rnorm(2, 0, FEMALE_SPEED);
					while (!individual.subpopulation.pointInBounds(position));
					offspring.setSpatialPosition(position);
				} else {
					// Torroidal world offspring placement.
					position = individual.spatialPosition + rnorm(2, 0, FEMALE_SPEED);
					offspring.setSpatialPosition(p1.pointPeriodic(position));
				}
			}
		}
	}
}


//modify child differently based on whether or not the father had the drive
1: modifyChild() {
	//figure out the father based on which parent had the tag value of 0.0
	if (parent1.tagF==0.0) {
		father = parent1;
		paternalGenome = childGenome1;
		mother = parent2;
		maternalGenome = childGenome2;
	} else {
		father = parent2;
		paternalGenome = childGenome2;
		mother = parent1;
		maternalGenome = childGenome1;
	}
	
	// if the father didn't have drive, there's no need to call germline resistance
	if (father.countOfMutationsOfType(m2)==0) {
		child.tagF = asFloat(rdunif(1,0,1)); //child gets a random gender
	} else {
		//figure out which genome the father had drive on. 
		//if this is an X_SHREDDER, this should be genome 2
		//if this is a Y_SHREDDER, this should be genome 1.
		if (father.genome1.countOfMutationsOfType(m2) == NUM_GRNAS) {
			fatherDriveGenome = father.genome1;
			fatherWTGenome = father.genome2;
		} else {
			fatherDriveGenome = father.genome2;
			fatherWTGenome = father.genome1; }
		
		//if the child received drive, child is a male.
		child_received_drive = paternalGenome.countOfMutationsOfType(m2) == NUM_GRNAS;
		
		//if the child didn't receive the drive chromosome, then the
		//child received the father's non-d chromosome, which went through
		//germline resistance
		if (!child_received_drive) {
			germline(paternalGenome, father, GERMLINE_RESISTANCE_RATE);
			
			//if there was a cut, loop back
			//1/2 the time, drive is actually passed. 
			//1/2 the time, call germline again (only exits here if no cutting occurs)
			while (paternalGenome.countOfMutationsOfType(m4) > 0) {
				if (runif(1) < 0.5)
					paternalGenome.addNewDrawnMutation(m2, seqLen(NUM_GRNAS));
				else {
					copy_genome(fatherWTGenome, paternalGenome);
					germline(paternalGenome, father, GERMLINE_RESISTANCE_RATE);
				}
			}
		}
		
		//update booleans
		child_received_drive = paternalGenome.countOfMutationsOfType(m2)==NUM_GRNAS;
		
		//drive alleles are on the Y-chromosome for the X_SHREDDER drive
		//and on the X-chromosome for the Y_SHREDDER drive
		if (X_SHREDDER)
			child.tagF = ifelse(child_received_drive, 0.0, 1.0);
		else if (Y_SHREDDER)
			child.tagF = ifelse(paternalGenome.countOfMutationsOfType(m2)==NUM_GRNAS, 1.0, 0.0);
	}
	
	if (Y_SHREDDER)
		embryo(maternalGenome,paternalGenome, mother);
	
	if (paternalGenome.countOfMutationsOfType(m4)) //shred
		return F;
	
	if (child.tagF==0.0 & MALE_MATE_CAP)
		child.setValue("mates", 0); //track mating history of new male offspring
	
	return T;
}


//// COLOR RULES FOR SLIM GUI DISPLAY.
early() {
	all = sim.subpopulations.individuals;
	males = all[all.tagF == 0.0];
	females = all[all.tagF == 1.0];
	males.color = "dodgerblue4"; //wt males are dark green
	females.color = "deepskyblue3"; //wt females are light green
	
	males[males.countOfMutationsOfType(m3) >= NUM_GRNAS].color = "darkgoldenrod1"; // gold if male and r1/(not d and not r2)
	females[females.countOfMutationsOfType(m3) >= NUM_GRNAS].color = "gold";  // light gold if female and r1/(not d and not r2)
	
	males[males.countOfMutationsOfType(m4) > 0].color = "purple"; //dark purple if male with no drives and at least one r2
	females[females.countOfMutationsOfType(m4) > 0].color = "mediumpurple1"; //light purple if female with no drives and at least one r2
	
	males[males.countOfMutationsOfType(m2) >= NUM_GRNAS].color = "firebrick"; //dark red if drive-carrying male
	females[females.countOfMutationsOfType(m2) >= NUM_GRNAS].color = "firebrick1"; //light red if drive-carrying female
}


//// EVALUATE SPATIAL INTERACTIONS BETWEEN INDIVIDUALS FOR OTHER FUNCTIONS.
late() {
	i1.evaluate();
	i2.evaluate();
	
	//subset all non-drive individuals
	all = sim.subpopulations.individuals;
	wt = all.countOfMutationsOfType(m2) == 0;
	wts = all[wt];
	num_wt = size(wts);
	
	//track clustering between wt individuals
	if (TRACK_RIPLEYS_L & sim.generation >= 10) {
		wts_before = sim.getValue("wts");
		sim.setValue("wts", c(wts_before, size(wts)));
		i3.evaluate();
		
		//Ripley's L calculation
		K = sum(i3.totalOfNeighborStrengths(wts));
		L = sqrt(K/PI) - DENSITY_INTERACTION_DISTANCE;
		catn("GEN: " + sim.generation + " RIPLEY's K: " + K);
		catn("RIPLEY'S L: " + L);
		l_before = sim.getValue("L");
		sim.setValue("L", c(l_before, L)); //store this L	
	}
}

//interaction between wt individuals only
interaction(i3) {
	if (!TRACK_RIPLEYS_L)
		return;
	
	if (receiver.countOfMutationsOfType(m2)!=0 | exerter.countOfMutationsOfType(m2) != 0)
		return 0.0;
	
	//receiver and exerter are now both wt
	W = sim.getValue("wts");
	W = W[(length(W)-1)];
	return (1/(W^2));
}


//// SURVIVAL RULES FOR THE SIMULATION BASED ON AGE AND RULES FOR MOVEMENT.
late() {
	all = sim.subpopulations.individuals;
	is_female = all.tagF == 1.0;
	females = all[is_female];
	males = all[!is_female];
	
	//by default, create non-overlapping generations
	males.fitnessScaling = 0.0;
	females.fitnessScaling = 0.0;
	
	//user may allow some females to live on
	if (RATE_FEMALES_SURVIVE > 0.0) {
		num_survive = round(RATE_FEMALES_SURVIVE*size(females));
		fem_survive = sample(females, num_survive);
		fem_survive.fitnessScaling = 1.0;
	}
	
	surviving_inds = all[all.fitnessScaling > 0.0];
	
	//surviving individuals move
	for (ind in surviving_inds) {
		if (REPRISING_BOUNDARIES) {
			// Movement within reprising boundaries.
			do position = ind.spatialPosition + rnorm(2, 0, FEMALE_SPEED);
			while (!ind.subpopulation.pointInBounds(position));
			ind.setSpatialPosition(position);
		}
		else {
			// Torroidal world movement.
			ind.x = ind.x + rnorm(1, 0, FEMALE_SPEED);
			ind.y = ind.y + rnorm(1, 0, FEMALE_SPEED);
			ind.setSpatialPosition(p1.pointPeriodic(ind.spatialPosition));
		}
	}
}


////SET UP THE POPULATION
1 {
	// Start with a population of wild type flies.
	sim.addSubpop("p1", CAPACITY);
	all = p1.individuals;
	all.tagF = asFloat(rdunif(CAPACITY, 0, 1));
	
	// Add wt to every gRNA spot
	all.genomes.addNewDrawnMutation(m1, seqLen(NUM_GRNAS));
	
	if (MALE_MATE_CAP) {
		is_male = all.tagF==0.0;
		all[is_male].setValue("mates",0);
	}
	
	if (!START_AT_CHASE) {
		// Start individuals scattered at random.
		all.x = runif(CAPACITY);
		all.y = runif(CAPACITY);
	
	} else {
		
		//If START_AT_CHASE is T, start with wt and drive in a corner
		
		all.x = rnorm(CAPACITY, 0.2, 1.5*DROP_RADIUS);
		all.y = rnorm(CAPACITY, 0.2, 1.5*DROP_RADIUS);
		all.color = "gold";
		
		sim.addSubpop("p2", DROP_SIZE);
		drop = p2.individuals;
		drop.color = "gold";
		
		if (MALE_ONLY_DROP)
			drop.tagF = rep(0.0, DROP_SIZE); //tag value of 0 acts as male sex
		
		else if (FEMALE_ONLY_DROP)
			drop.tagF = rep(1.0, DROP_SIZE); //tag value of 0 acts as male sex
		
		else
			drop.tagF = asFloat(rdunif(DROP_SIZE, 0, 1)); //random sexes
		
		// Now set the drop individuals to the correct genotypes:
		drop.genomes.addNewDrawnMutation(m2,seqLen(NUM_GRNAS));
		
		females = (drop.tagF == 1.0);
		males = (drop.tagF == 0.0);
		
		//if this is an X_SHREDDER, only Y chromosome has the drive. All X chromosomes should be wt
		if (X_SHREDDER) {
			drop[females].genomes.addNewDrawnMutation(m1, seqLen(NUM_GRNAS)); //females cannot get the drive
			drop[males].genome1.addNewDrawnMutation(m1, seqLen(NUM_GRNAS)); //maternal genome gets wt
			drop[males].genome2.addNewDrawnMutation(m2, seqLen(NUM_GRNAS)); //paternal genome gets drive
		}
		
		//if this is an Y_SHREDDER, only X chromsomes can have the drive. All Y chromosomes should be wt
		if (Y_SHREDDER) {
			drop[females].genomes.addNewDrawnMutation(m2, seqLen(NUM_GRNAS)); //females get drive on both chromosomes
			
			if (HETEROZYGOUS_DROP) //if this is a heterozygous drop, drive females are (X^d X^wt)
				drop[females].genome2.addNewDrawnMutation(m1, seqLen(NUM_GRNAS));
			
			drop[males].genome1.addNewDrawnMutation(m2, seqLen(NUM_GRNAS)); //maternal genome is X; gets X^d
			drop[males].genome2.addNewDrawnMutation(m1, seqLen(NUM_GRNAS)); //paternal genome is a Y; stays wt
		}
		
		// Move all the individuals from the drop into p1:
		p1.takeMigrants(drop);
		
		drop.x = rnorm(DROP_SIZE, 0.2, DROP_RADIUS);
		drop.y = rnorm(DROP_SIZE, 0.2, DROP_RADIUS);
		drop[drop.tagF == 0.0].setValue("mates", 0); //track males' mates
	}
	
	sim.setValue("track_eq", NULL);
	
	//	//code for plotting the number of wt alleles
	//	defineConstant("pdfPath", writeTempFile("plot_", ".pdf", "")); //create temporary PDF of wt alleles
	//	
	//	if (exists("slimgui"))
	//		slimgui.openDocument(pdfPath); //open graph
}

//code for plotting the number of wt alleles
//1: late() {
//	
//	//	wtCount = sum(sim.subpopulations.individuals.genomes.countOfMutationsOfType(m1) == NUM_GRNAS);
//	//	h = c(sim.getValue("wts"), wtCount);
//	//	sim.setValue("wts", h);
//	
//	//	//plotting
//	//	{
//	//		rstr = paste(c('{',
//	//			'x = (0:' + (size(h)-1) + ')',
//	//			'y = c(' + paste(h,sep=", ") + ')',
//	//			'quartz(width = 10, height = 10, type = "pdf", file = "' + pdfPath + '")',
//	//			'plot(x=x,y=y,xlim = c(-10,200), ylim = c(0, 30000), type = "l", ylab="#wt alleles", xlab="generation")',
//	//			'dev.off()',
//	//			'}'), sep='\n');
//	//		
//	//		
//	//		scriptPath = writeTempFile("plot_", ".R", rstr);
//	//		system("/usr/local/bin/Rscript", args=scriptPath);
//	//	}

//}

//// DROP A GROUP OF MODIFIED INDIVIDUALS INTO THE POPULATION.
10 {
	
	if (START_AT_CHASE | NO_DROP)
		return;
	
	sim.addSubpop("p2", DROP_SIZE);
	drop = p2.individuals;
	drop.color = "gold";
	
	if (MALE_ONLY_DROP)
		drop.tagF = rep(0.0, DROP_SIZE); //tag value of 0 acts as male sex
	
	else if (FEMALE_ONLY_DROP)
		drop.tagF = rep(1.0, DROP_SIZE); //tag value of 0 acts as male sex
	
	else
		drop.tagF = asFloat(rdunif(DROP_SIZE, 0, 1)); //random sexes
	
	females = (drop.tagF == 1.0);
	males = (drop.tagF == 0.0);
	
	//if this is an X_SHREDDER, only Y chromosome has the drive. All X chromosomes should be wt
	if (X_SHREDDER) {
		drop[females].genomes.addNewDrawnMutation(m1, seqLen(NUM_GRNAS)); //females cannot get the drive
		drop[males].genome1.addNewDrawnMutation(m1, seqLen(NUM_GRNAS)); //maternal genome gets wt
		drop[males].genome2.addNewDrawnMutation(m2, seqLen(NUM_GRNAS)); //paternal genome gets drive
	} //end X_SHREDDER
	
	//if this is an Y_SHREDDER, only X chromsomes can have the drive. All Y chromosomes should be wt
	if (Y_SHREDDER) {
		drop[females].genomes.addNewDrawnMutation(m2, seqLen(NUM_GRNAS)); //females get drive on both chromosomes
		
		if (HETEROZYGOUS_DROP) //if this is a heterozygous drop, drive females are (X^d X^wt)
			drop[females].genome2.addNewDrawnMutation(m1, seqLen(NUM_GRNAS));
		
		drop[males].genome1.addNewDrawnMutation(m2, seqLen(NUM_GRNAS)); //maternal genome is X; gets X^d
		drop[males].genome2.addNewDrawnMutation(m1, seqLen(NUM_GRNAS)); //paternal genome is a Y; stays wt
	} //end Y_SHREDDER
	
	// Move all the individuals from the drop into p1:
	p1.takeMigrants(drop);
	
	if (LEFT_EDGE_DROP) { //left-rectangle drop
		drop.x = runif(DROP_SIZE, 0, 0.1);
		drop.y = runif(DROP_SIZE);
	
	} else if (CIRCLE_DROP) { //default circle drop
		drop.x = 0.5 + rnorm(DROP_SIZE, 0, DROP_RADIUS);
		drop.y = 0.5 + rnorm(DROP_SIZE, 0, DROP_RADIUS);
	}
	
	if (MALE_MATE_CAP)
		drop[drop.tagF == 0.0].setValue("mates", 0); //track males' mates
	
	if (TRACK_RIPLEYS_L) {
		sim.setValue("wts", NULL);
		sim.setValue("L", NULL);
	}
	
	if (TRACK_BY_CELL) {
		sim.setValue("start_gc_tracking", F); //don't start until number of wt alleles falls below 80% eq
		sim.setValue("GC", NULL);
	}
}


////PROGRAM OUTPUT AFTER DROP.
10: late() {
	//population size
	all = p1.individuals;
	is_male = all.tagF==0.0;
	males = all[is_male];
	females = all[!is_male];
	pop_size = size(all);
	num_females = size(females);
	num_males = size(males);
	this_gen = sim.generation-10;
	
	//count of chromosomes
	num_y = num_males;
	num_x = 2*num_females + num_males;
	num_autosomal_chromosomes = 2*pop_size;
	
	//allele counts
	num_wt = sum(males.genome1.countOfMutationsOfType(m1)==NUM_GRNAS) + sum(females.genomes.countOfMutationsOfType(m1)==NUM_GRNAS);
	rate_wt = num_wt/num_x;
	
	if (X_SHREDDER) {
		num_dr = sum(males.genome2.countOfMutationsOfType(m2)==NUM_GRNAS);
		rate_dr = num_dr/num_y;
	} else if (Y_SHREDDER) {
		num_dr = sum(males.genome1.countOfMutationsOfType(m2) == NUM_GRNAS) + sum(females.genomes.countOfMutationsOfType(m2)==NUM_GRNAS);
		rate_dr = num_dr/num_x;
	}
	
	//first check for a chase
	if (num_wt < EQUILIBRIUM_WT_ALLELE_THRESHOLD) {
		catn("POTENTIAL_CHASE:: " + this_gen);
		
		if (TRACK_BY_CELL) {
			if (!sim.getValue("start_gc_tracking"))
				sim.setValue("start_gc_tracking", T); //now start tracking by cell
		}
	}
	
	//output for python
	if (NO_DROP)
		sim.setValue("start_gc_tracking", T); //start tracking GC
	else {
		catn("GEN: "+this_gen+" RATE_DR: " + rate_dr);
		if (!TRACK_BY_CELL)
			catn("WT_ALLELES:: " + num_wt + " " + this_gen + " " + pop_size);
	}
	
	//record the number of wts in each cell
	if (TRACK_BY_CELL)  {
		//only start recording once the number of WT alleles first falls below 80% of equilibrium
		if (sim.getValue("start_gc_tracking")) {
			inds = all[all.countOfMutationsOfType(m2) == 0]; //obtain non-drive individuals
			x = inds.x;
			y = inds.y;
			
			pos_vec = 0:(sqrt(NUMBER_OF_CELLS) - 1);
			dim = length(pos_vec);
			cell_width = 1.0/dim;
			positions = pos_vec * cell_width; //iterate through these x and y positions
			
			gen_track = c(); //record all cell counts for THIS generation
			
			for (i in 0:(dim-1)) {
				div_left = positions[i];
				for (j in 0:(dim-1)) {
					div_bot = positions[j];
					in_division = (x >= div_left) & (x < div_left + cell_width) & (y >= div_bot) & (y < div_bot + cell_width);
					inds_in_cell = inds[in_division];
					cell_count = size(inds_in_cell); //number in this cell
					gen_track = c(gen_track, cell_count); //add this onto this generation's count tracker
				}
			} //done obtaining cell counts
			
			//Green's Coefficient is a measure of clustering for this generation
			//when individuals are completely randomly distributed, GC = 0. 
			//when individuals are as clustered as possible, GC = 1.
			
			pop_size = sum(gen_track);
			
			//prevent nan errors
			if (pop_size > 1) {
				greens_coeff = (var(gen_track)/mean(gen_track) - 1)/(sum(gen_track) - 1);
				catn("WT_ALLELES:: " + num_wt + " " + this_gen + " " + pop_size +" " + "GC_SPACE::" + " " + greens_coeff); //check detection methods
				
				//a row will represent one cell's population history throughout time
				//a column will give one generation's cell counts
				gc_history = sim.getValue("GC");
				
				if (isNULL(gc_history)) {
					gc_history = c(greens_coeff); //create the GC history vector if not already created
					sim.setValue("GC", gc_history);
				
				} else {
					gc_history = c(gc_history, greens_coeff); //append to the vector
					sim.setValue("GC", gc_history);
				}
			}
		}
	}
	
	if (NO_DROP)
		return;
	
	//// conditions that may stop the simulation for SUPPRESSION drives:
	
	//1-drive was lost and wt population remained
	if (num_dr == 0 & pop_size>0) {
		catn("POP_PERSISTS:: " + this_gen);
		
		if (TRACK_RIPLEYS_L)
			outputRipleysL("pers");
		if (TRACK_BY_CELL & CSV_FOR_GC)
			outputGreensCoefficient("pers");
		sim.simulationFinished();
	}
	
	//2-equilibrium state attained
	if (rate_dr== 1 & pop_size > 0) {
		start = sim.getValue("track_eq");
		if (isNULL(start)) {
			sim.setValue("track_eq", 1);
		} else if (start == 10) { //only allow state for 10 generations
			started_at = this_gen - 10;
			catn("EQUILIBRIUM:: " + started_at);
			
			if (TRACK_RIPLEYS_L)
				outputRipleysL("eq");
			
			if (TRACK_BY_CELL & CSV_FOR_GC)
				outputGreensCoefficient("eq");
			
			sim.simulationFinished();
		} else {
			elapsed = start + 1;
			sim.setValue("track_eq", elapsed);
		}
	}
	
	//3-suppression occurs
	if (pop_size == 0){
		catn("SUPPRESSED:: " + this_gen);
		if (TRACK_RIPLEYS_L)
			outputRipleysL("supp");
		if (TRACK_BY_CELL & CSV_FOR_GC)
			outputGreensCoefficient("supp");
		sim.simulationFinished();
	}
}

//if no drop, stop after 100 generations of tracking
100 late() {
	if (!NO_DROP)
		return;
	
	if (TRACK_BY_CELL & CSV_FOR_GC)
		outputGreensCoefficient("wt_end");
		
	sim.simulationFinished();

}

////output 1000 generations after drop if simulation hasn't ended already
1010 late() {
	
	if (TRACK_RIPLEYS_L)
		outputRipleysL("end");
	if (TRACK_BY_CELL & CSV_FOR_GC)
		outputGreensCoefficient("end");
	
	all = p1.individuals;
	all_males = all[all.tagF==0.0];
	has_drive = sum(all.countOfMutationsOfType(m2) >= NUM_GRNAS);
	rate_has_drive = has_drive/size(all_males);
	
	catn("ENDING_AFTER_1000:: " + rate_has_drive);
	sim.simulationFinished();
}

