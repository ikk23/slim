// Author: Sam Champer and Isabel Kim.
// Created in association with Jackson Champer and the Messer lab.

// A framework for simulating many different gene drives
// with varying parameters, intended to be configured by
// alterning the heading below, or by dynamically varying
// values in the header using an associated Python file.

//These gene drives are located on a different chromosome than their target sites.
//This landscape is simulated in 2 dimensions.

// The following header to be replaced via python,
// such that these values can be varied across multiple runs of slim.

initialize() {
	defineConstant("TWO_DIMENSIONAL",T); //if F, simulated in 1D
	
	//suppression drives
	defineConstant("TADS_AUTOSOMAL_SUPPRESSION", T);
	defineConstant("TADS_Y_SUPPRESSION", F);
	defineConstant("TADE_SUPPRESSION", F);
	defineConstant("TRACK_BY_CELL", T);
	defineConstant("SUPPRESSION_OUTPUT", TADS_AUTOSOMAL_SUPPRESSION | TADS_Y_SUPPRESSION | TADE_SUPPRESSION);
	
	//modification drives
	defineConstant("TADE", F);
	defineConstant("TADE_DOUBLE_RESCUE", F);
	defineConstant("TADS_MODIFICATION", F);
	defineConstant("TARE", F);
	defineConstant("TARE_UNDERDOMINANCE", F);
	defineConstant("X_LINKED_DRIVE", F);
	
	//drive parameters
	defineConstant("DRIVE_FITNESS_VALUE", 0.95);
	defineConstant("EMBRYO_RESISTANCE_RATE", 0.95);
	defineConstant("GERMLINE_RESISTANCE_RATE", 0.99);
	defineConstant("NUM_GRNAS", 1);
	defineConstant("R1_OCCURRENCE_RATE", 0.0);
	
	//ecology parameters
	defineConstant("GROWTH_AT_ZERO_DENSITY", 6);
	defineConstant("INBREEDING_AVOIDANCE_FACTOR", 0.0); //if negative, % inc. if positive, % dec.
	defineConstant("INBREEDING_FECUNDITY_PENALTY", 0.0); //from 0 - 1, always % dec.
	defineConstant("REPRISING_BOUNDARIES", T);
	
	//release specifics
	defineConstant("HETEROZYGOUS_DROP", T);
	defineConstant("DROP_RADIUS", 0.01);
	defineConstant("NO_DROP", F);
	defineConstant("MALE_ONLY_DROP", F); //use for TADS Y Suppression
	defineConstant("CIRCLE_DROP", T);
	defineConstant("LEFT_EDGE_DROP", F);
	defineConstant("UNIFORM_DROP", F);
	defineConstant("CORNER_DROP", F); //can use with torodial boundaries
	
	if (TWO_DIMENSIONAL) {
		defineConstant("CAPACITY", 10000);
		defineConstant("DENSITY_INTERACTION_DISTANCE", 0.01);
		defineConstant("DROP_SIZE",101);
		defineConstant("SPEED", 0.04);
		defineConstant("NUMBER_OF_CELLS", 64);
		defineConstant("EXPECTED_ADULT_COMPETITION", CAPACITY * PI * DENSITY_INTERACTION_DISTANCE^2);
	} else {
		defineConstant("CAPACITY", 3927);
		defineConstant("DENSITY_INTERACTION_DISTANCE", 0.002);
		defineConstant("DROP_SIZE",40);
		defineConstant("SPEED", 0.008);
		defineConstant("NUMBER_OF_CELLS", 40);
		defineConstant("EQUILIBRIUM_BIN_POPULATION", 0.5*CAPACITY/20);
		defineConstant("EXPECTED_ADULT_COMPETITION", CAPACITY * 2*DENSITY_INTERACTION_DISTANCE);
	}
	// */    // End header.
	
	// Below are defaults that will not change / are rarely used
	defineConstant("EQUILIBRIUM_WT_ALLELE_THRESHOLD", 0.8*2*CAPACITY);
	defineConstant("FEMALE_ONLY_DROP", F);
	defineConstant("FEMALE_SPEED", SPEED);
	defineConstant("GRNA_SATURATION_SIMULATED", F);
	defineConstant("LATE_GERMLINE_RESISTANCE_RATE", 0.9);
	defineConstant("MALE_ONLY_PROMOTER", F);
	defineConstant("MATING_DISTANCE", SPEED);
	defineConstant("MALE_MATE_CAP", F);
	defineConstant("MAX_MALE_MATINGS", 50);
	defineConstant("NUM_CUT_PHASES", 1);
	defineConstant("R2_FITNESS_VALUE", 1.0);
	defineConstant("HAPLOLETHAL", F);
	defineConstant("HAPLOSUFFICIENT", F);
	
	// For mortality rate as a function of age:
	// Some females are allowed to survive two generations:
	defineConstant("RATE_FEMALES_SURVIVE", 0.0);
	
	// This simulation will use a non-Wright-Fisher model.
	initializeSLiMModelType("nonWF");
	
	// This simulation will take place across continuous space.
	// By default, model occurs in a torroidal space to prevent edge effects.
	// The model tracks pedigrees in order to implement inbreeding avoidance.
	
	if (TWO_DIMENSIONAL) {
		if (REPRISING_BOUNDARIES)
			initializeSLiMOptions(keepPedigrees = T, dimensionality = "xy"); //for 1-D
		else
			initializeSLiMOptions(keepPedigrees=T, dimensionality="xy", periodicity="xy");
		
		// Mate searching:
		initializeInteractionType(1, "xy", reciprocal=T, maxDistance=MATING_DISTANCE);
		// Adult competition:
		initializeInteractionType(2, "xy", reciprocal=T, maxDistance=DENSITY_INTERACTION_DISTANCE);
	} else {
		if (REPRISING_BOUNDARIES)
			initializeSLiMOptions(keepPedigrees = T, dimensionality = "x"); //for 1-D
		else
			initializeSLiMOptions(keepPedigrees=T, dimensionality="x", periodicity="x");
		
		initializeInteractionType(1, "x", reciprocal=T, maxDistance=MATING_DISTANCE);
		initializeInteractionType(2, "x", reciprocal=T, maxDistance=DENSITY_INTERACTION_DISTANCE);
	}
	
	// Four variations: Wild type, drive, r1 resistance, r2 resistance.
	wt = initializeMutationType("m1", 0.5, "f", 0.0);
	dr_c1 = initializeMutationType("m8", 0.5, "f", 0.0); //used in tare underdominance
	dr_c2 = initializeMutationType("m2", 0.5, "f", 0.0);
	r1 = initializeMutationType("m3", 0.5, "f", 0.0);
	r2 = initializeMutationType("m4", 0.5, "f", 0.0);
	cut = initializeMutationType("m5", 0.5, "f", 0.0);
	gap = initializeMutationType("m6", 0.5, "f", 0.0);
	wt_c2 = initializeMutationType("m7", 0.5, "f", 0.0);
	
	// Alleles possible on c1, the cut-site chromosome:
	// drive (m2) is only possible if this is tare underdominance
	variations_c1 = c(dr_c1, wt, r1, r2, cut, gap);
	
	// Alleles possible on c2, the drive-containing chromosome:
	//if this is not tare underdominance, only m2 and m7 will be used. if this is tare underdominance, other alleles are possible.
	variations_c2 = c(dr_c2, wt_c2, r1, r2, cut, gap);
	
	// The chromosomes are simulated as seperate genomicElements.
	initializeGenomicElementType("g1", variations_c1, c(1, 1, 1, 1, 1,1));
	initializeGenomicElementType("g2", variations_c2, c(1,1,1,1,1,1));
	
	// Chromosome 1 is NUM_GRNAS long, each spot on the element representing a gRNA target site. 
	// Chromosome 2 is NUM_GRNAS long, representing the distant-site drive chromosome. Only in tare underdominance does this chromosome
	// also represent a cut chromosome. 
	initializeGenomicElement(g1, 0, NUM_GRNAS - 1);
	initializeGenomicElement(g2, 1 + NUM_GRNAS, (2*NUM_GRNAS));
	
	// These mutations overwrite one another.
	variations_c1.mutationStackPolicy = "l";
	variations_c1.mutationStackGroup = 1;
	variations_c2.mutationStackPolicy = "l";
	variations_c2.mutationStackGroup = 1;
	
	// No mutation in this model.
	initializeMutationRate(0.0);
	
	// Recombination rate of 50% simulates separate chromosomes.
	initializeRecombinationRate(c(0.0, 0.5, 0.0), c(NUM_GRNAS-1, NUM_GRNAS, (2*NUM_GRNAS)));
	
	// Simulate sexual reproduction: A for autosome.
	initializeSex("A");
}


//// FUNCTION FOR EVALUATING POPULATION SUPPRESSION WITH HAPLOLETHAL STYLE SUPPRESSION.
function (logical)isHLSuppressed(o<Individual>$ ind) {
	// Check both chromosomes for the drive.	
	// Individual cannot reproduce if both chromosomes have a drive.
	if (sum(ind.genomes.countOfMutationsOfType(m2)==NUM_GRNAS)==2)
		return T;
	return F;
}

//// HELPER FUNCTION FOR FORMING A RESISTANCE ALLELE AT A GIVEN LOCUS.
function (void)addResistanceAllele(o<Genome>$ genome, i$ locus) {
	// Resistance alleles form at a specified rate.	m3 is r1, m4 is r2.
	genome.addNewDrawnMutation(ifelse((runif(1) < R1_OCCURRENCE_RATE), m3,m4), locus);
}

//// FUNCTION FOR CAS9 EFFECTS IN THE GERMLINE.
function (void)germline(o<Genome>$ child_chromosome, o<Individual>$ parent, f$ resistance_rate) {
	// Determine presence of drive in this parent.
	parent_drive_count = sum(parent.genomes.countOfMutationsOfType(m2) == NUM_GRNAS);
	parent_drive2_count = sum(parent.genomes.countOfMutationsOfType(m8)==NUM_GRNAS);
	// If parent doesn't have drive allele, nothing happens in germline.
	if (!parent_drive_count & !TARE_UNDERDOMINANCE)
		return;
	if (TARE_UNDERDOMINANCE & !(parent_drive_count|parent_drive2_count))
		return;
	
	// Chromosome must have wt to cut, or nothing happens.
	if (child_chromosome.countOfMutationsOfType(m1) == 0 & !TARE_UNDERDOMINANCE)
		return;
	
	if (TARE_UNDERDOMINANCE) {
		if (!(child_chromosome.countOfMutationsOfType(m1)|child_chromosome.countOfMutationsOfType(m7))) //nothing to cut
			return;
		// If child has wt m1, check for drive m2 to target. If child has wt m7, check for drive m8 to target
		target_wt1 = ifelse((child_chromosome.countOfMutationsOfType(m1) & parent_drive_count),T,F);
		target_wt2 = ifelse((child_chromosome.countOfMutationsOfType(m7) & parent_drive2_count),T,F);
		if (!(target_wt1|target_wt2)) //drives and wt's don't match
			return;
	}
	
	// Using the resistance rate passed to the function,
	// determine the per phase cut rate.
	grna_factor = 1;
	if (GRNA_SATURATION_SIMULATED)
		grna_factor = NUM_GRNAS;
	per_phase_cut_rate = 1 - (1 - resistance_rate)^(1 / (NUM_CUT_PHASES * grna_factor));
	
	// Determine if cas9 cuts the chromosome in the germline
	if (!TARE_UNDERDOMINANCE)
		//default arguments will make it so the WT of m1 type can be cut; disregard WT of m7 type
		casCut(child_chromosome, per_phase_cut_rate);
	else
		casCut(child_chromosome, per_phase_cut_rate, target_wt1, target_wt2);
}

//// FUNCTION FOR CAS9 EFFECTS IN EMBRYO.
function (void)embryo(o<Genome>$ child_chromosome_1, o<Genome>$ child_chromosome_2, o<Individual>$ mother) {
	// Determine presence of drive in this mother.
	mother_drive_count = sum(mother.genomes.countOfMutationsOfType(m2) == NUM_GRNAS);
	mother_drive2_count = sum(mother.genomes.countOfMutationsOfType(m8) == NUM_GRNAS);
	// If mother doesn't have drive allele, nothing happens in embryo.
	if (!mother_drive_count & !TARE_UNDERDOMINANCE)
		return;
	if (TARE_UNDERDOMINANCE & !(mother_drive_count|mother_drive2_count))
		return;
	
	// Determine the per phase cut rate.
	grna_factor = 1;
	
	if (GRNA_SATURATION_SIMULATED)
		grna_factor = NUM_GRNAS;
	per_phase_cut_rate = 1 - (1 - EMBRYO_RESISTANCE_RATE)^(mother_drive_count / (NUM_CUT_PHASES * grna_factor));
	
	if (TARE_UNDERDOMINANCE) {
		//if child has wt m1, check for drive m2 in mother. if child has wt m7, check for drive m8 in mother. repeat for both chromosomes
		target_wt1_c1 = ifelse((child_chromosome_1.countOfMutationsOfType(m1) & mother_drive_count),T,F);
		target_wt2_c1 = ifelse((child_chromosome_1.countOfMutationsOfType(m7) & mother_drive2_count),T,F);
		target_wt1_c2 = ifelse((child_chromosome_2.countOfMutationsOfType(m1) & mother_drive_count),T,F);
		target_wt2_c2 = ifelse((child_chromosome_2.countOfMutationsOfType(m7) & mother_drive2_count),T,F);
		
		//call casCut given these updated logicals
		casCut(child_chromosome_1, per_phase_cut_rate, target_wt1_c1, target_wt2_c1);
		casCut(child_chromosome_2, per_phase_cut_rate, target_wt1_c2, target_wt2_c2);
	} //end tare underdominance
	
	else {
		casCut(child_chromosome_1, per_phase_cut_rate);
		casCut(child_chromosome_2, per_phase_cut_rate);
	}
}

//// FUNCTION FOR CAS9 CUTTING A TARGET CHROMOSOME.
//// default to only create the vector of target sites for type m1
function (void)casCut(o<Genome>$ chromosome, f$ per_phase_cut_rate, [logical$ target_wt1 = T], [logical$ target_wt2 = F]) {
	// If chromosome has no wild type targets to cut, cas9 does nothing.
	// Vector of possible loci for cas9 to cut (loci 1 in the case of tare underdominance)
	if (target_wt1) {
		wt_loci = chromosome.positionsOfMutationsOfType(m1);
		// In each cut phase...
		for (i in seqLen(NUM_CUT_PHASES)) {
			// At each possible locus...
			for (j in seqAlong(wt_loci)) {
				// Check to see if cas9 cuts...
				if (runif(1) < per_phase_cut_rate) {
					// Convert the locus temporarily to an m5,
					// representing that this site is being cut.
					chromosome.addNewDrawnMutation(m5, wt_loci[j]);
				}
			}
			// If any cuts were made...
			if (chromosome.countOfMutationsOfType(m5)) {
				cut_loci = chromosome.positionsOfMutationsOfType(m5);
				// If just one cut is made, create an R1 or R2 resistance allele.
				if (chromosome.countOfMutationsOfType(m5) == 1)
					addResistanceAllele(chromosome, cut_loci[0]);
				else {
					// If mutlple cuts are made in the same cut phase, loss of
					// function results. Convert leftmost site to m4 (R2)
					// everthing else through the rightmost site to m6 (cut).
					number_of_cuts = cut_loci[size(cut_loci) - 1] - cut_loci[0];
					for (index in seqLen(number_of_cuts))
						chromosome.addNewDrawnMutation(m6, cut_loci[0] + index + 1);
					chromosome.addNewDrawnMutation(m4, cut_loci[0]);
				}
				// Because some wt loci may have been cut out of the
				// chromosome, remake the vector of possible cut sites.
				if (chromosome.countOfMutationsOfType(m1) == 0)   {
					if ((!TARE_UNDERDOMINANCE) | (TARE_UNDERDOMINANCE & !target_wt2))
						return;
				} //exit function here if all the gRNA sites are now r1 or r2, and there are no more wt targets (as in TARE Underdominance)
				if (chromosome.countOfMutationsOfType(m1))
					wt_loci = chromosome.positionsOfMutationsOfType(m1);
			}
		}
	}
	
	//If this is TARE Underdominance, may repeat cleavage for loci 2
	if (target_wt2) {
		wt_loci_2 = chromosome.positionsOfMutationsOfType(m7);
		// In each cut phase...
		for (i in seqLen(NUM_CUT_PHASES)) {
			// At each possible locus...
			for (j in seqAlong(wt_loci_2)) {
				// Check to see if cas9 cuts...
				if (runif(1) < per_phase_cut_rate) {
					// Convert the locus temporarily to an m5,
					// representing that this site is being cut.
					chromosome.addNewDrawnMutation(m5, wt_loci_2[j]);
				}
			}
			// If any cuts were made...
			if (chromosome.countOfMutationsOfType(m5)) {
				cut_loci = chromosome.positionsOfMutationsOfType(m5);
				// If just one cut is made, create an R1 or R2 resistance allele.
				if (chromosome.countOfMutationsOfType(m5) == 1)
					addResistanceAllele(chromosome, cut_loci[0]);
				else {
					// If mutlple cuts are made in the same cut phase, loss of
					// function results. Convert leftmost site to m4 (R2)
					// everthing else through the rightmost site to m6 (cut).
					number_of_cuts = cut_loci[size(cut_loci) - 1] - cut_loci[0];
					for (index in seqLen(number_of_cuts))
						chromosome.addNewDrawnMutation(m6, cut_loci[0] + index + 1);
					chromosome.addNewDrawnMutation(m4, cut_loci[0]);
				}
				// Because some wt loci may have been cut out of the
				// chromosome, remake the vector of possible cut sites.
				if (chromosome.countOfMutationsOfType(m7) == 0)
					return; //can now exit function 
				wt_loci_2 = chromosome.positionsOfMutationsOfType(m7);
			}
		}
	}
}

//// HELPER FUNCTION TO OVERWRITE ONE DRIVE CHROMOSOME WITH ANOTHER.
function (void)copy_drive_chromosome(o<Genome>$ source, o<Genome>$ destination) {
	for (i in seqAlong(source.positionsOfMutationsOfType(m2)))
		destination.addNewDrawnMutation(m2, source.positionsOfMutationsOfType(m2)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m7)))
		destination.addNewDrawnMutation(m7, source.positionsOfMutationsOfType(m7)[i]);
}

//// HELPER FUNCTION TO OVERWRITE ONE GENOME WITH ANOTHER.
//// IF DRIVE_COPIED IS SET TO FALSE, THEN ONLY THE CUT CHROMOSOME IS COPIED
function (void)copy_genome(o<Genome>$ source, o<Genome>$ destination, [logical$ drive_copied = T]) {
	for (i in seqAlong(source.positionsOfMutationsOfType(m1))) //m1 loci (wt)
		destination.addNewDrawnMutation(m1, source.positionsOfMutationsOfType(m1)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m3))) //m3 loci (r1)
		destination.addNewDrawnMutation(m3, source.positionsOfMutationsOfType(m3)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m4))) //m4 loci (r2)
		destination.addNewDrawnMutation(m4, source.positionsOfMutationsOfType(m4)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m5))) //m5 loci (cut)
		destination.addNewDrawnMutation(m5, source.positionsOfMutationsOfType(m5)[i]);
	for (i in seqAlong(source.positionsOfMutationsOfType(m6))) //m6 loci (gap)
		destination.addNewDrawnMutation(m6, source.positionsOfMutationsOfType(m6)[i]);
	if (drive_copied) {
		for (i in seqAlong(source.positionsOfMutationsOfType(m2))) //m2 loci (dr)
			destination.addNewDrawnMutation(m2, source.positionsOfMutationsOfType(m2)[i]);
	}
}

//// RULES FOR FITNESS BASED ON GENOTYPE.
function (f$)genotypeFitness(o<Individual>$ ind) {
	
	//put the panmictic TARE_UNDERDOMINANCE fitness check in later
	
	// Representation of the value of the two chromosomes. Check for drive or wt to get the baseline value.
	c1_value = ifelse(ind.genome1.countOfMutationsOfType(m2) == NUM_GRNAS, DRIVE_FITNESS_VALUE, 1.0);
	c2_value = ifelse(ind.genome2.countOfMutationsOfType(m2) == NUM_GRNAS, DRIVE_FITNESS_VALUE, 1.0);
	
	// Check both chromosomes for r2's.
	if (ind.genome1.countOfMutationsOfType(m4) > 0)
		c1_value = c1_value*R2_FITNESS_VALUE;
	if (ind.genome2.countOfMutationsOfType(m4) > 0)
		c2_value = c2_value*R2_FITNESS_VALUE;
	
	return ifelse(TADS_Y_SUPPRESSION, c2_value, sqrt(c1_value * c2_value)); //tads y suppression fitness values are based on the drive chromosome
}


//// REPRODUCTION RULES FOR EACH FEMALE.
reproduction(NULL, "F") {
	// First, evaluate whether reproduction is suppressed by a population suppression drive,
	// Then, select a mate based on fitness, then generate offspring.
	
	// Suppression drives:
	if (TADE_SUPPRESSION)
		if (isHLSuppressed(individual))
			return;
	
	all_neighbors = i1.nearestNeighbors(individual, subpop.individualCount);
	neighbors = all_neighbors[all_neighbors.sex == "M"]; //male neighbors
	if (size(neighbors) == 0) // If no mates are in mate detection range, cannot mate.
		return;
	attempt_no = 0;
	while (1) {
		// First, select a random mate.
		mate_no = 0;
		if (size(neighbors) > 1)
			mate_no = rdunif(1, max=size(neighbors) - 1);
		selected_mate = neighbors[mate_no];
		// Determine attractiveness of mate.
		mate_attractiveness = 0.5*genotypeFitness(selected_mate);
		
		//inbreeding avoidance factor represents the percent decrease in attractiveness of a brother if positive
		//and a percent increase in attractiveness of a brother if negative
		if (selected_mate.pedigreeParentIDs[0] == individual.pedigreeParentIDs[0] & individual.pedigreeParentIDs[0] != -1)
			mate_attractiveness = mate_attractiveness * (1 - INBREEDING_AVOIDANCE_FACTOR);
		
		// Determine if this mate is chosen, based on attractiveness and number of mates so far.
		if (MALE_MATE_CAP) {
			
			if ((runif(1) < mate_attractiveness) & (selected_mate.getValue("mates") < MAX_MALE_MATINGS)) {
				selected_mate.setValue("mates", selected_mate.getValue("mates") + 1); //increment his mate count
				break;
			}
		} else {
			if (runif(1) < mate_attractiveness)
				break;
		}
		// After twenty candidates fail, female gives up.
		attempt_no = attempt_no + 1;
		if (attempt_no == 19)
			return;
	} //Mate has now been selected.
	
	// Amount of competition faced per expected competition.
	adult_density_force = i2.totalOfNeighborStrengths(individual);
	competition_ratio = adult_density_force / EXPECTED_ADULT_COMPETITION;
	actual_competition_factor = GROWTH_AT_ZERO_DENSITY/ ((GROWTH_AT_ZERO_DENSITY-1) * competition_ratio + 1);
	
	// Offspring number based on binomial distrobution.
	// p for binomial draw. Number of offspring varies with female genes and competition.
	p = genotypeFitness(individual) * actual_competition_factor * 0.04 / (1 + RATE_FEMALES_SURVIVE);
	
	//inbreeding fecundity penalty represents a % decrease in the probability of generating offspring due to inbreeding
	if (selected_mate.pedigreeParentIDs[0] == individual.pedigreeParentIDs[0] & individual.pedigreeParentIDs[0] != -1)
		p = p * (1-INBREEDING_FECUNDITY_PENALTY);
	
	num_offspring = rbinom(1, 50, p);
	
	// In the TADS modification drive, (wt/wt r2/r2) males are sterile
	// In TADS autosomal supression drive, drive homozygous males are also sterile.
	if (TADS_MODIFICATION | TADS_AUTOSOMAL_SUPPRESSION) {
		num_drives = sum(selected_mate.genomes.countOfMutationsOfType(m2)==NUM_GRNAS);
		if (sum(selected_mate.genomes.countOfMutationsOfType(m4) > 0) == 2 & num_drives==0)
			num_offspring = 0;
		if (TADS_AUTOSOMAL_SUPPRESSION & num_drives==2)
			num_offspring = 0;
	}
	
	//if this is TADS Y Suppression but the father is wildtype, or if this isn't TADS Y Suppression, then offspring are generated normally.
	if ((TADS_Y_SUPPRESSION & selected_mate.genome2.countOfMutationsOfType(m2) == 0) | !TADS_Y_SUPPRESSION ) {
		for (i in seqLen(num_offspring)) {
			// Add offspring to the subpopulation.
			offspring = subpop.addCrossed(individual, selected_mate);
			if (!isNULL(offspring)) {
				
				if (TWO_DIMENSIONAL) {
					if (REPRISING_BOUNDARIES) {
						// Offspring placement within reprising boundaries.
						do position = individual.spatialPosition + rnorm(2, 0, FEMALE_SPEED);
						while (!individual.subpopulation.pointInBounds(position));
						offspring.setSpatialPosition(position);
					}
					else {
						// Torroidal world offspring placement.
						position = individual.spatialPosition + rnorm(2, 0, FEMALE_SPEED);
						offspring.setSpatialPosition(p1.pointPeriodic(position));
					}
				} else {
					if (REPRISING_BOUNDARIES) {
						// Offspring placement within reprising boundaries.
						do position = individual.spatialPosition + rnorm(1, 0, FEMALE_SPEED);
						while (!individual.subpopulation.pointInBounds(position));
						offspring.setSpatialPosition(position);
					}
					else {
						// Torroidal world offspring placement.
						position = individual.spatialPosition + rnorm(1, 0, FEMALE_SPEED);
						offspring.setSpatialPosition(p1.pointPeriodic(position));
					}
				}
			}
		}
	} else {
		//save initial state of his chromosomes - will need to revert to this for each offspring generated
		m1_pos_c1 = selected_mate.genome1.positionsOfMutationsOfType(m1);
		m2_pos_c1 = selected_mate.genome1.positionsOfMutationsOfType(m2);
		m3_pos_c1 = selected_mate.genome1.positionsOfMutationsOfType(m3);
		m4_pos_c1 = selected_mate.genome1.positionsOfMutationsOfType(m4);
		m5_pos_c1 = selected_mate.genome1.positionsOfMutationsOfType(m5);
		m6_pos_c1 = selected_mate.genome1.positionsOfMutationsOfType(m6);
		
		m1_pos_c2 = selected_mate.genome2.positionsOfMutationsOfType(m1);
		m2_pos_c2 = selected_mate.genome2.positionsOfMutationsOfType(m2);
		m3_pos_c2 = selected_mate.genome2.positionsOfMutationsOfType(m3);
		m4_pos_c2 = selected_mate.genome2.positionsOfMutationsOfType(m4);
		m5_pos_c2 = selected_mate.genome2.positionsOfMutationsOfType(m5);
		m6_pos_c2 = selected_mate.genome2.positionsOfMutationsOfType(m6);
		
		
		// Simulate a new germline resistance event for each offspring to be generated
		for (i in seqLen(num_offspring)) {
			casCut(selected_mate.genome1, GERMLINE_RESISTANCE_RATE); //apply mutations to his genomes and save his initial state
			casCut(selected_mate.genome2, GERMLINE_RESISTANCE_RATE);
			count_r2 = sum(selected_mate.genomes.countOfMutationsOfType(m4) > 0);
			
			// CASE 1 - if r2/r2, generate a male child with the drive
			// ensure that the male child receives the d with the r2 by placing the drive on both of the father's chromosomes
			if (count_r2 == 2) {
				selected_mate.genomes.addNewDrawnMutation(m2, seq(1 + NUM_GRNAS, 2 * NUM_GRNAS, length = NUM_GRNAS));
				offspring = subpop.addCrossed(individual, selected_mate, 1.0);
			} //end case 1
			
			//CASE 2 - if r2/nonr2, 3 sperm are possible: (d r2 = male), (d nonr2 = male), and (wt nonr2 = female) 
			else if (count_r2 == 1)  {
				if (selected_mate.genome1.countOfMutationsOfType(m4) > 0) {  //first identify the r2 chromosome
					r2_chrom = selected_mate.genome1;
					nonr2_chrom = selected_mate.genome2;
				}
				else {
					r2_chrom = selected_mate.genome2;
					nonr2_chrom = selected_mate.genome1;
				}
				
				// 1/3 of the time, mate passes on (d r2) to a son
				if (runif(1) < 1/3) {
					copy_genome(r2_chrom, nonr2_chrom);
					selected_mate.genomes.addNewDrawnMutation(m2, seq(1 + NUM_GRNAS, 2 * NUM_GRNAS, length = NUM_GRNAS));
					offspring = subpop.addCrossed(individual, selected_mate, 1.0);
				}
				
				// 2/3 of the time, the nonr2 chromosome is passed
				else {
					copy_genome(nonr2_chrom, r2_chrom);
					if (runif(1) < 0.5) { // the sex chromosome can be X (wt female) or Y (drive male)
						selected_mate.genomes.addNewDrawnMutation(m2, seq(1 + NUM_GRNAS, 2 * NUM_GRNAS, length = NUM_GRNAS));
						offspring = subpop.addCrossed(individual, selected_mate, 1.0);
					}
					else {
						selected_mate.genomes.addNewDrawnMutation(m7, seq(1 + NUM_GRNAS, 2 * NUM_GRNAS, length = NUM_GRNAS));
						offspring = subpop.addCrossed(individual, selected_mate, 0.0);
					}
				}
			} //end case 2
			
			// CASE 3: no r2's on either autosome - child can be generated normally.
			else if (count_r2 == 0)
				offspring = subpop.addCrossed(individual, selected_mate); //end case 3
			
			// Recreate the father's initial autosomes for the next loop
			
			selected_mate.genome1.removeMutations();
			selected_mate.genome2.removeMutations();
			
			for (pos in m1_pos_c1)
				selected_mate.genome1.addNewDrawnMutation(m1, pos);
			for (pos in m2_pos_c1)
				selected_mate.genome1.addNewDrawnMutation(m2, pos);
			for (pos in m3_pos_c1)
				selected_mate.genome1.addNewDrawnMutation(m3, pos);
			for (pos in m4_pos_c1)
				selected_mate.genome1.addNewDrawnMutation(m4, pos);
			for (pos in m5_pos_c1)
				selected_mate.genome1.addNewDrawnMutation(m5, pos);
			for (pos in m6_pos_c1)
				selected_mate.genome1.addNewDrawnMutation(m6, pos);
			
			for (pos in m1_pos_c2)
				selected_mate.genome2.addNewDrawnMutation(m1, pos);
			for (pos in m2_pos_c2)
				selected_mate.genome2.addNewDrawnMutation(m2, pos);
			for (pos in m3_pos_c2)
				selected_mate.genome2.addNewDrawnMutation(m3, pos);
			for (pos in m4_pos_c2)
				selected_mate.genome2.addNewDrawnMutation(m4, pos);
			for (pos in m5_pos_c2)
				selected_mate.genome2.addNewDrawnMutation(m5, pos);
			for (pos in m6_pos_c2)
				selected_mate.genome2.addNewDrawnMutation(m6, pos);

			if (!isNULL(offspring)) {
				
				if (TWO_DIMENSIONAL) {
					if (REPRISING_BOUNDARIES) {
						// Offspring placement within reprising boundaries.
						do position = individual.spatialPosition + rnorm(2, 0, FEMALE_SPEED);
						while (!individual.subpopulation.pointInBounds(position));
						offspring.setSpatialPosition(position);
					}
					else {
						// Torroidal world offspring placement.
						position = individual.spatialPosition + rnorm(2, 0, FEMALE_SPEED);
						offspring.setSpatialPosition(p1.pointPeriodic(position));
					}
				} else {
					if (REPRISING_BOUNDARIES) {
						// Offspring placement within reprising boundaries.
						do position = individual.spatialPosition + rnorm(1, 0, FEMALE_SPEED);
						while (!individual.subpopulation.pointInBounds(position));
						offspring.setSpatialPosition(position);
					}
					else {
						// Torroidal world offspring placement.
						position = individual.spatialPosition + rnorm(1, 0, FEMALE_SPEED);
						offspring.setSpatialPosition(p1.pointPeriodic(position));
					}
				}
			}
		
		} //end for-loop for each offspring
	} //end else TADS-Y and father has drive
}


//// GENE DRIVE IMPLEMENTATION RULES THAT OCCUR IN EVERY CHILD.
1: modifyChild() {
	
	// If the drive is x-linked, prevent it from being inherited on Y chromosome:
	if (X_LINKED_DRIVE) {
		if(child.sex == "M")
			copy_drive_chromosome(parent2Genome2, child.genome2);
		if(child.sex == "F")
			copy_drive_chromosome(parent2Genome1, child.genome2);
	}
	
	//ensure that drive corresponds to males and wt to females
	if (TADS_Y_SUPPRESSION & parent2.genome2.countOfMutationsOfType(m2) == NUM_GRNAS)
		child.genome2.addNewDrawnMutation(ifelse(childIsFemale, m7,m2), seq(1 + NUM_GRNAS, 2 * NUM_GRNAS, length = NUM_GRNAS));
	
	if (TADS_MODIFICATION | TADS_AUTOSOMAL_SUPPRESSION) {
		// Apply germline resistance
		if (!MALE_ONLY_PROMOTER)
			germline(childGenome1, parent1, GERMLINE_RESISTANCE_RATE);
		germline(childGenome2, parent2, GERMLINE_RESISTANCE_RATE);
		
		//useful booleans
		father_r2_on_c1_genome1 = (parent2Genome1.countOfMutationsOfType(m4) > 0);
		father_r2_on_c1_genome2 = (parent2Genome2.countOfMutationsOfType(m4) > 0);
		
		//if the father was d/wt
		if (sum(parent2.genomes.countOfMutationsOfType(m2) == NUM_GRNAS)==1) {
			
			//CASE 1 - enters while-loop if the child obtained (wt r2) from ( d/wt non(r2/r2) ) father
			if (!(father_r2_on_c1_genome1 & father_r2_on_c1_genome2)) {
				while (childGenome2.countOfMutationsOfType(m4) > 0 & childGenome2.countOfMutationsOfType(m7) == NUM_GRNAS) {
					
					if (runif(1) < 0.5) //half the time, child actually received the drive and can exit the loop as (d r2)
						childGenome2.addNewDrawnMutation(m2,seq(1 + NUM_GRNAS, 2 * NUM_GRNAS, length = NUM_GRNAS));
					
					else {
						//the other half the time, call germline resistance again on the cut chromosome
						// if the father was originally (r2 / nonr2) on his cut chromosome, call germline again on father's nonr2 chromosome 2
						if (father_r2_on_c1_genome1 & !father_r2_on_c1_genome2)
							copy_genome(parent2Genome2, childGenome2, F);
						
						// if the father was originally (nonr2 / r2) on his cut chromosome, call germline again on father's nonr2 chromosome 1
						if (father_r2_on_c1_genome2 & !father_r2_on_c1_genome1)
							copy_genome(parent2Genome1, childGenome2,F);
						
						// if the father was originally (nonr2 / nonr2) on his cut chromosome, randomly choose the chromosome that'll undergo germline res again
						if ((!father_r2_on_c1_genome1) & (!father_r2_on_c1_genome2))
							copy_genome(ifelse(runif(1) < 0.5, parent2Genome2, parent2Genome1), childGenome2, F);
						
						germline(childGenome2, parent2, GERMLINE_RESISTANCE_RATE); //only exits loop here if the child no longer has r2 on his autosome
					}
				}
			}
			
			// CASE 2- father was (d/wt r2/r2) - child must have received (d/r2) 
			else
				childGenome2.addNewDrawnMutation(m2, seq(1 + NUM_GRNAS, 2 * NUM_GRNAS, length = NUM_GRNAS));
		}
		
		// CASE 3- father was (wt/wt r2/nonr2) - child must receive (wt nonr2)
		if (sum(parent2.genomes.countOfMutationsOfType(m7) == NUM_GRNAS) == 2 & childGenome2.countOfMutationsOfType(m4) > 0) {
			//if r2 occurred on father's genome1, give the child his chromosome2. If not, give the child his chromosome1.
			copy_genome(ifelse(parent2Genome1.countOfMutationsOfType(m4) > 0, parent2Genome2, parent2Genome1), childGenome2, F);
		}
		
		// Apply effects that happen in the embryo.
		if (!MALE_ONLY_PROMOTER)
			embryo(childGenome1, childGenome2, parent1);
	}
	
	//Applicable to TADE and TARE 
	if (!(TADS_MODIFICATION|TADS_AUTOSOMAL_SUPPRESSION|TADS_Y_SUPPRESSION)) {
		// Apply effects that happen in the germline.
		if (!MALE_ONLY_PROMOTER)
			germline(childGenome1, parent1, GERMLINE_RESISTANCE_RATE);
		germline(childGenome2, parent2, GERMLINE_RESISTANCE_RATE);
		
		// Apply effects that happen in the embryo.
		if (!MALE_ONLY_PROMOTER)
			embryo(childGenome1, childGenome2, parent1);
	}
	
	// If the drive is x-linked, prevent gene drive mechanics on Y chromosome by resetting it:
	if (X_LINKED_DRIVE) {
		if(child.sex == "M")
			copy_drive_chromosome(parent2Genome2, child.genome2);
		if(child.sex == "F")
			copy_drive_chromosome(parent2Genome1, child.genome2);
	}
	
	// Offspring may be non viable offspring if drive
	// is haplolethal or haplosufficient recesive lethal.
	// Booleans describing prescence of alleles:
	no_drive_c_1 = childGenome1.countOfMutationsOfType(m2)==0;
	no_drive_c_2 = childGenome2.countOfMutationsOfType(m2)==0;
	num_drives = sum(child.genomes.countOfMutationsOfType(m2)==NUM_GRNAS);
	num_r2s = sum(child.genomes.countOfMutationsOfType(m4)>0);
	
	// haplolethal applies in TADE and TADE Suppression drives or if programmed
	haplolethal_one_rescue = ifelse((TADE|TADE_SUPPRESSION|HAPLOLETHAL),T,F);
	
	// haplosufficiency rules apply in TARE or if programmed
	haplosufficiency = ifelse(TARE|HAPLOSUFFICIENT, T, F);
	
	// If drive is haplolethal with only one rescue, apply both checks.
	// If this is TADE double rescue, then offspring is only inviable when it is (wt/wt r2/-).
	
	// if one target gene is disrupted, there's no drive to rescue, and gene is haplolethal, offspring dies
	if ((haplolethal_one_rescue|TADE_DOUBLE_RESCUE) & num_r2s > 0 & num_drives==0)
		return F;
	
	// if both copies of the target gene are disrupted, gene is haplosufficient, and we don't have
	// two recoded copies, offspring dies.
	if ((haplosufficiency|haplolethal_one_rescue) & num_r2s==2 & num_drives < 2)
		return F;
	
	// for TARE underdominance, genotype r2/r2  on either loci will result in a nonviable embryo
	if (TARE_UNDERDOMINANCE) {
		r2_loci1_c1 = ifelse(childGenome1.containsMarkerMutation(m4,seqLen(NUM_GRNAS)), T, F);
		r2_loci2_c1 = ifelse(childGenome1.containsMarkerMutation(m4,seq(1 + NUM_GRNAS, 2 * NUM_GRNAS, length = NUM_GRNAS)), T, F);
		r2_loci1_c2 = ifelse(childGenome2.containsMarkerMutation(m4,seqLen(NUM_GRNAS)), T, F);
		r2_loci2_c2 = ifelse(childGenome2.containsMarkerMutation(m4,seq(1 + NUM_GRNAS, 2 * NUM_GRNAS, length = NUM_GRNAS)), T, F);
		if ((r2_loci1_c1 & r2_loci1_c2) | (r2_loci2_c1 & r2_loci2_c2))
			return F;
	}
	
	if (!childIsFemale & MALE_MATE_CAP)
		child.setValue("mates", 0);
	
	return T;
}


//// COLOR RULES FOR SLIM GUI DISPLAY.
early() {
	all = sim.subpopulations.individuals;
	all.color = "blue"; // wt individuals are blue
	two_res = (all.genome1.countOfMutationsOfType(m4) | all.genome1.countOfMutationsOfType(m3) == NUM_GRNAS) & (all.genome2.countOfMutationsOfType(m4) | all.genome2.countOfMutationsOfType(m3) == NUM_GRNAS);
	all[two_res].color = "yellow"; //resistance homozygotes are yellow
	all[all.countOfMutationsOfType(m2) >= NUM_GRNAS].color = "red"; //drive-carrying individuals are red
}


//// EVALUATE SPATIAL INTERACTIONS BETWEEN INDIVIDUALS FOR OTHER FUNCTIONS.
late() {
	i1.evaluate();
	i2.evaluate();

}

//// SURVIVAL RULES FOR THE SIMULATION BASED ON AGE AND RULES FOR MOVEMENT.
late() {
	all = sim.subpopulations.individuals;
	is_male = all.sex=="M";
	
	//by default, create non-overlapping generations
	all[is_male].fitnessScaling = 0.0;
	females = all[!is_male];
	females.fitnessScaling = 0.0;
	
	//user may allow some females to survive
	if (RATE_FEMALES_SURVIVE > 0.0) {
		num_survive = round(RATE_FEMALES_SURVIVE*size(females));
		fem_survive = sample(females, num_survive);
		fem_survive.fitnessScaling = 1.0;
	}
	
	surviving_inds = all[all.fitnessScaling > 0.0];
	
	//surviving individuals move
	for (ind in surviving_inds) {
		if (REPRISING_BOUNDARIES) {
			// Movement within reprising boundaries.
			if (TWO_DIMENSIONAL) {
				do position = ind.spatialPosition + rnorm(2, 0, FEMALE_SPEED);
				while (!ind.subpopulation.pointInBounds(position));
				ind.setSpatialPosition(position);
			} else {
				do position = ind.spatialPosition + rnorm(1, 0, FEMALE_SPEED);
				while (!ind.subpopulation.pointInBounds(position));
				ind.setSpatialPosition(position);
			}
		} else {
			// Torroidal world movement.
			if (TWO_DIMENSIONAL) {
				ind.x = ind.x + rnorm(1, 0, FEMALE_SPEED);
				ind.y = ind.y + rnorm(1, 0, FEMALE_SPEED);
				ind.setSpatialPosition(p1.pointPeriodic(ind.spatialPosition));
			} else {
				ind.x = ind.x + rnorm(1, 0, FEMALE_SPEED);
				ind.setSpatialPosition(p1.pointPeriodic(ind.spatialPosition));
			}
		}
	}
}


//// START THE SIMULATION BY ADDING AN INITIAL WILD POPULATION.
1 {
	// Start with a population of wild type flies.
	sim.addSubpop("p1", CAPACITY);
	
	all = p1.individuals;
	
	// Add wt to the cut-chromosome
	all.genomes.addNewDrawnMutation(m1, seqLen(NUM_GRNAS));
	
	// Add wt to the drive chromosome
	all.genomes.addNewDrawnMutation(m7, seq(1 + NUM_GRNAS, 2 * NUM_GRNAS, length = NUM_GRNAS));
	
	// Start individuals scattered at random.
	if (TWO_DIMENSIONAL) {
		all.x = runif(CAPACITY);
		all.y = runif(CAPACITY);
	} else {
		all.x = p1.pointUniform(CAPACITY);
		sim.setValue("timer", "start");
	}
	
	if (MALE_MATE_CAP)
		all[all.sex=="M"].setValue("mates", 0);
	
	if (SUPPRESSION_OUTPUT)
		sim.setValue("track_eq", NULL);
}


//// DROP A GROUP OF MODIFIED INDIVIDUALS INTO THE POPULATION.
10 {
	
	if (NO_DROP)
		return;
	
	// Add a drop of modified individuals to p1.
	if (MALE_ONLY_DROP)
		// Drop a population of only males.
		sim.addSubpop("p2", DROP_SIZE, 1.0);
	else if (FEMALE_ONLY_DROP)
		// Drop a population of only females.
		sim.addSubpop("p2", DROP_SIZE, 0.0);
	else
		sim.addSubpop("p2", DROP_SIZE);
	
	drop = p2.individuals;
	
	// Set the drop individuals to the correct genotypes:
	drop.genomes.addNewDrawnMutation(m1, seqLen(NUM_GRNAS)); // By default, cut chromosome is wt.
	drop.genomes.addNewDrawnMutation(m2, seq(1 + NUM_GRNAS, 2 * NUM_GRNAS, length = NUM_GRNAS)); // Drive chromosome is always drive.
	
	if (HETEROZYGOUS_DROP) // Heterozygous drop: one of the chromosomes set back to wt:
		drop.genome1.addNewDrawnMutation(m7, seq(1 + NUM_GRNAS, 2 * NUM_GRNAS, length = NUM_GRNAS));
	
	if (TADS_Y_SUPPRESSION) { // In TADS_Y_SUPPRESSION only males' genome2 contains the drive.
		// Set all X chromosomes to wt, only Y has drive.
		drop[drop.sex == "F"].genomes.addNewDrawnMutation(m7,seq(1 + NUM_GRNAS, 2 * NUM_GRNAS, length = NUM_GRNAS));
		drop[drop.sex == "M"].genome1.addNewDrawnMutation(m7, seq(1 + NUM_GRNAS, 2 * NUM_GRNAS, length = NUM_GRNAS));
	}
	
	if (X_LINKED_DRIVE) // In X_LINKED_DRIVE males' genome2 is always wt.
		drop[drop.sex == "M"].genome2.addNewDrawnMutation(m7, seq(1 + NUM_GRNAS, 2 * NUM_GRNAS)); // Set all Y chromosomes to wt.
	
	if (TARE_UNDERDOMINANCE) {
		// locus 1: drive is m8, wt is m1; locus 2: drive is m2, wt is m7
		// use homozygous drops for this drive	
		drop.genomes.addNewDrawnMutation(m8, seqLen(NUM_GRNAS)); // add drive to locus 1
		drop.genomes.addNewDrawnMutation(m2, seq(1 + NUM_GRNAS, 2 * NUM_GRNAS, length = NUM_GRNAS)); //add drive to locus 2
	}
	
	// Move all the individuals from the drop into p1:
	p1.takeMigrants(drop);
	
	if (TWO_DIMENSIONAL) {
		if (LEFT_EDGE_DROP) { //left-rectangle drop
			drop.x = runif(DROP_SIZE, 0, DROP_RADIUS);
			drop.y = runif(DROP_SIZE);
		} else if (CIRCLE_DROP) { //default circle drop
			drop.x = 0.5 + rnorm(DROP_SIZE, 0, DROP_RADIUS);
			drop.y = 0.5 + rnorm(DROP_SIZE, 0, DROP_RADIUS);
		} else if (UNIFORM_DROP) { //scattered uniformly
			drop.x = runif(DROP_SIZE);
			drop.y = runif(DROP_SIZE);
		} else if (CORNER_DROP) {
			for (ind in drop) {
				ind.x = rnorm(1, 0, DROP_RADIUS);
				ind.y = rnorm(1, 0, DROP_RADIUS);
				ind.setSpatialPosition(p1.pointPeriodic(ind.spatialPosition));
			}
		}
	} else {
		//only left-edge drops are possible for 1D
		drop.x = runif(DROP_SIZE, 0, DROP_RADIUS);
	}
	
	if (MALE_MATE_CAP)
		drop[drop.tagF == 0.0].setValue("mates", 0); //track males' mates
	
	if (TRACK_BY_CELL)
		sim.setValue("start_gc_tracking", F); //don't start until number of wt alleles falls below 80% eq

}


//// PROGRAM OUTPUT AFTER DROP.
10: late() {
	
	// population size
	all = sim.subpopulations.individuals;
	pop_size = length(all);
	males = all[all.sex=="M"];
	num_males = length(males);
	females = all[all.sex=="F"];
	num_females = length(females);
	this_gen = sim.generation-10;
	
	//count of chromosomes
	num_y = num_males;
	num_x = 2*num_females + num_males;
	num_autosomal_chromosomes = 2*pop_size;
	
	//other alleles
	num_wt = sum(all.genomes.countOfMutationsOfType(m1)==NUM_GRNAS);
	num_r1_aut = sum(all.genomes.countOfMutationsOfType(m3)==NUM_GRNAS);
	catn("R1 COUNT: " + num_r1_aut);
	num_r2_aut = sum(all.genomes.countOfMutationsOfType(m4) > 0);
	
	//rates used by both
	rate_wt =  num_wt/num_autosomal_chromosomes;
	rate_r1_aut = num_r1_aut/num_autosomal_chromosomes;
	rate_r2_aut = num_r2_aut/num_autosomal_chromosomes;
	
	//output that doesn't apply to TADS Y
	if (!(TADS_Y_SUPPRESSION|TARE_UNDERDOMINANCE)) {
		num_dr = sum(all.genomes.countOfMutationsOfType(m2)==NUM_GRNAS);
		rate_dr =  num_dr/num_autosomal_chromosomes;
		
		//		num_wt_chrom2 = sum(all.genomes.countOfMutationsOfType(m7)==NUM_GRNAS);
		//		num_at_least_one_drive = sum(all.countOfMutationsOfType(m2) >= NUM_GRNAS);
		//		percent_with_one_or_more_drive = num_at_least_one_drive/pop_size;
		//		rate_wt_chrom2 = num_wt_chrom2/num_autosomal_chromosomes;
		
		//output specific to TADS Y
	} else if (TADS_Y_SUPPRESSION) {
		num_dr = sum(males.genome2.countOfMutationsOfType(m2)==NUM_GRNAS);
		rate_dr = num_dr/num_y;
		num_wt_y = num_males - num_dr;
		rate_wt_y = num_wt_y/num_y;
		
		//output specific to TARE UNDERDOMINANCE
	} else if (TARE_UNDERDOMINANCE) {
		
		num_dr = sum(all.genomes.countOfMutationsOfType(m8)==NUM_GRNAS);
		rate_dr = num_dr_loci1/num_autosomal_chromosomes;
		num_wt_loci2 = sum(all.genomes.countOfMutationsOfType(m7)==NUM_GRNAS);
		//		num_dr_loci2 = sum(all.genomes.countOfMutationsOfType(m2)==NUM_GRNAS);
		//		freq_wt_loci2 = num_wt_loci2/num_autosomal_chromosomes;
		//		freq_dr_loci2 = num_dr_loci2/num_autosomal_chromosomes;
	}
	
	//CHASING ANALYSIS
	if (SUPPRESSION_OUTPUT) {
		
		if (num_wt < EQUILIBRIUM_WT_ALLELE_THRESHOLD) {
			catn("POTENTIAL_CHASE:: " + this_gen);
			
			if (TRACK_BY_CELL) {
				if (!sim.getValue("start_gc_tracking"))
					sim.setValue("start_gc_tracking", T); //now start tracking by cell
			}
		}
		
		//output for python
		if (NO_DROP)
			sim.setValue("start_gc_tracking", T); //always track GC for wt only runs
		else {
			catn("GEN: "+this_gen+" RATE_DR: " + rate_dr);
			if (!TRACK_BY_CELL)
				catn("WT_ALLELES:: " + num_wt + " " + this_gen + " " + pop_size);
		}
		
		if (TWO_DIMENSIONAL) {
			
			//record quadrant counts and calculate greens coefficient for chasing
			//detection and overall
			if (TRACK_BY_CELL)  {
				//only start recording once the number of WT alleles first falls below 80% of equilibrium
				if (sim.getValue("start_gc_tracking")) {
					
					nondrive = all[all.countOfMutationsOfType(m2) == 0]; //obtain non-drive individuals
					nonx = nondrive.x;
					nony = nondrive.y;
					allx = all.x; //also track overall green's coefficient
					ally = all.y;
					pos_vec = 0:(sqrt(NUMBER_OF_CELLS) - 1);
					dim = length(pos_vec);
					cell_width = 1.0/dim;
					positions = pos_vec * cell_width; //iterate through these x and y positions
					nondrive_track = c(); //used for chasing detection
					all_track = c(); //report always
					
					for (i in 0:(dim-1)) {
						div_left = positions[i];
						for (j in 0:(dim-1)) {
							div_bot = positions[j];
							
							nondrive_in_division = (nonx >= div_left) & (nonx < (div_left + cell_width)) & (nony >= div_bot) & (nony < (div_bot + cell_width));
							nondrive_in_cell = nondrive[nondrive_in_division];
							nondrive_cell_count = size(nondrive_in_cell); //number in this cell
							nondrive_track = c(nondrive_track, nondrive_cell_count); //add this onto this generation's count tracker
							
							all_in_division = (allx >= div_left) & (allx < (div_left + cell_width)) & (ally >= div_bot) & (ally < (div_bot + cell_width));
							all_in_cell = all[all_in_division];
							all_cell_count = size(all_in_cell);
							all_track = c(all_track, all_cell_count);
						}
					} //done obtaining cell counts
					
					//Green's Coefficient is a measure of clustering for this generation
					//when individuals are completely randomly distributed, GC = 0.
					//when individuals are as clustered as possible, GC = 1.
					
					nondrive_pop_size = sum(nondrive_track);
					
					//prevent nan errors
					if (nondrive_pop_size > 1) {
						nondrive_greens_coeff = (var(nondrive_track)/mean(nondrive_track) - 1)/(sum(nondrive_track) - 1);
						all_greens_coeff = (var(all_track)/mean(all_track) - 1)/(sum(all_track)-1);
						// (1) number wt alleles (2) gen (3) population size (5) gc for chase detection (7) overall gc
						catn("WT_ALLELES:: " + num_wt + " " + this_gen + " " + pop_size +" " + "GC_SPACE::" + " " + nondrive_greens_coeff + " " + "OVERALL_GC::" + " " + all_greens_coeff);
					}
				}
			}
			
			//1d analysis
		} else {
			
			//time from one side of the landscape to the other
			timer = sim.getValue("timer");
			
			//only start timer once
			//skip over this once once the timer has been stopped
			if (timer!="stopped") {
				all_x = all.x;
				at_start = (all_x >= 0.25) & (all_x <= 0.3);
				inds_start = all[at_start];
				
				if (size(inds_start) <= EQUILIBRIUM_BIN_POPULATION) {
					if (timer=="start") {
						catn("starting timer at " + this_gen);
						sim.setValue("timer", this_gen);
					}
				}
				at_end = (all_x >= 0.75) & (all_x <= 0.8);
				inds_end = all[at_end];
				
				if (size(inds_end) <= EQUILIBRIUM_BIN_POPULATION) {
					if (timer!= "start") {
						start_gen = sim.getValue("timer");
						gens_elapsed = this_gen - start_gen;
						catn("stopping timer at " + this_gen);
						catn("TIMED_GENS:: " + gens_elapsed);
						sim.setValue("timer", "stopped"); //stop tracking this 
					}
				}
			}
			
			if (TRACK_BY_CELL)  {
				inds = all[all.countOfMutationsOfType(m2) == 0]; //non drive individuals
				x = inds.x;
				pos_vec = 0:(NUMBER_OF_CELLS - 1);
				dim = length(pos_vec);
				cell_width = 1.0/dim;
				positions = pos_vec * cell_width;
				
				gen_track = c(); //record all cell counts for THIS generation
				
				
				for (i in 0:(dim-1)) {
					div_left = positions[i];
					in_division = (x >= div_left) & (x < (div_left + cell_width));
					inds_in_cell = inds[in_division];
					cell_count = size(inds_in_cell);
					if ((length(gen_track) > 0)) {
						if ((cell_count < 10) & sum(gen_track) > 50)
							catn("CHASE_GEN:: " + this_gen);
					}
					gen_track = c(gen_track, cell_count);
				}
				
				//Green's Coefficient is a measure of clustering for this generation
				//when individuals are completely randomly distributed, GC = 0. 
				//when individuals are as clustered as possible, GC = 1.
				pop_size = sum(gen_track);
				
				//prevent nan errors
				if (pop_size > 1) {
					greens_coeff = (var(gen_track)/mean(gen_track) - 1)/(sum(gen_track) - 1);
					catn("WT_ALLELES:: " + num_wt + " " + this_gen + " " + pop_size +" " + "GC_SPACE::" + " " + greens_coeff); //check detection methods
				}
			}
			if (this_gen >= 5) {
				has_drive = all.countOfMutationsOfType(m2)>=NUM_GRNAS;
				drive_inds = all[has_drive].x;
				if (size(drive_inds) > 0) {
					thickness = max(drive_inds) - min(drive_inds);
					catn("THICKNESS:: " + thickness);
				}
			}
		
		}
		
		if (NO_DROP)
			return;
		
		//// conditions that may stop the simulation for SUPPRESSION drives:
		
		//1-drive was lost and wt population remained
		if (num_dr == 0 & pop_size>0) {
			catn("POP_PERSISTS:: " + this_gen);
			
			sim.simulationFinished();
		}
		
		//2-equilibrium state attained
		if (rate_dr== 1 & pop_size > 0) {
			start = sim.getValue("track_eq");
			if (isNULL(start)) {
				sim.setValue("track_eq", 1);
			} else if (start == 10) { //only allow state for 10 generations
				started_at = this_gen - 10;
				catn("EQUILIBRIUM:: " + started_at);
				sim.simulationFinished();
			} else {
				elapsed = start + 1;
				sim.setValue("track_eq", elapsed);
			}
		}
		
		//3-suppression occurs
		if (pop_size == 0){
			catn("SUPPRESSED:: " + this_gen);
			sim.simulationFinished();
		}
		
		//4-resistance allele formation
		if (num_r1_aut >= 10000) {
			catn("RESISTANCE:: " + this_gen);
			sim.simulationFinished();
		}
	} //end Suppression output
}

//if no drop, stop after 100 generations of tracking
100 late() {
	if (!NO_DROP)
		return;
	
	sim.simulationFinished();

}

////output 1000 generations after drop if simulation hasn't ended already
1010 late() {
	all = p1.individuals;
	has_drive = sum(all.countOfMutationsOfType(m2) >= NUM_GRNAS);
	rate_has_drive = has_drive/size(all);
	
	catn("ENDING_AFTER_1000:: " + rate_has_drive);
	sim.simulationFinished();
}




